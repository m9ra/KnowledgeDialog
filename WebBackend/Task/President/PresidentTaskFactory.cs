using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using KnowledgeDialog.Knowledge;

namespace WebBackend.Task.President
{
    /// <summary>
    /// Factory of tasks from president domain.
    /// </summary>
    class PresidentTaskFactory : TaskFactoryBase
    {
        /// <summary>
        /// All available task patterns.
        /// </summary>
        private readonly List<TaskPatternBase> _taskPatterns = new List<TaskPatternBase>();

        /// <summary>
        /// All valid task pattern-substitution pairs.
        /// </summary>
        private readonly List<Tuple<TaskPatternBase, int>> _validTasks = new List<Tuple<TaskPatternBase, int>>();

        internal PresidentTaskFactory(bool enableCheckAndLearn = true)
        {
            var g = Program.Graph;
            if (!enableCheckAndLearn)
                TaskPatternUtilities.DisableCheckAndLearn();

            add(new PresidentChildrenTask(g));
            add(new PresidentOfStateTask(g));
            add(new StateOfPresidentTask(g));
            add(new WifeOfPresidentTask(g));
            add(new DaughterOfTask(g));
            add(new PlaceOfBornTask(g));
            add(new PresidentFatherTask(g));
            add(new PresidentMotherTask(g));
            add(new SonOfTask(g));

            generateTaskPairs();
        }

        ///<inheritdoc/>
        internal override TaskInstance CreateInstance(int taskId, int taskIndex, int validationCode)
        {
            if (_validTasks.Count <= taskIndex)
                //there are no other tasks.
                return null;

            var validTaskPatternPair = _validTasks[taskIndex];
            var taskPattern = validTaskPatternPair.Item1;
            var substitutionIndex = validTaskPatternPair.Item2;

            var substitution = taskPattern.GetSubstitution(substitutionIndex);
            var expectedAnswers = taskPattern.GetExpectedAnswers(substitutionIndex);

            return new TaskInstance(taskId, taskPattern.PatternFormat, new[] { substitution }, expectedAnswers, getKey(taskPattern), validationCode);
        }

        ///<inheritdoc/>
        internal override int GetTaskCount()
        {
            return _validTasks.Count;
        }

        /// <summary>
        /// Generates valid task-substitution pairs.
        /// </summary>
        private void generateTaskPairs()
        {
            foreach (var task in _taskPatterns)
            {
                for (var i = 0; i < task.SubstitutionCount; ++i)
                {
                    var substitution = task.GetSubstitution(i);
                    var answers = task.GetExpectedAnswers(i);
                    if (!answers.Any())
                        //there is no valid answer - we will skip this task
                        continue;

                    _validTasks.Add(Tuple.Create(task, i));
                }
            }
        }

        /// <summary>
        /// Adds task pattern.
        /// </summary>
        /// <param name="pattern">Added task pattern.</param>
        private void add(TaskPatternBase pattern)
        {
            _taskPatterns.Add(pattern);
        }

        /// <summary>
        /// Gets the key of tasks generated by given pattern.
        /// </summary>
        /// <param name="pattern">Pattern which tasks' key is returned.</param>
        /// <returns>Pattern tasks' key/</returns>
        private string getKey(TaskPatternBase pattern)
        {
            return pattern.GetType().ToString();
        }
    }
}
